---
auto:
---

# 设计模式概述

> 引入设计模式的目的是为了更好的重用代码、使代码更清晰，可靠性更强，更便于他人理解。
> 设计模式六大原则

- 开闭原则（对扩展开放，对修改关闭）
- 里氏替换原则
- 依赖倒转原则
  - 针对接口编程，依赖于抽象而不依赖于具体
- 接口隔离原则
  - 使用多个隔离的接口，比使用单个接口要好。降低类之间的耦合度
- 迪米特法则（最少知道原则）
  - 一个实体应当尽量少地与其他实体之间发生相互作用，是的系统功能模块相对独立
- 合成复用原则
  - 尽量使用合成/聚合的方式，而不是继承

## 创建模式

### 工厂模式

#### 作用

- 主要解决接口选择问题，不同条件下创建不同实例
- 子类实现工厂接口，返回的也是一个抽象的产品
- 创建过程在其子类执行

#### 使用

- 定义接口，抽象具体行为
- 子类实现接口
- 创建工厂，根据给定的信息返回不同的子类对象
- 使用工厂

### 抽象工厂模式

#### 比较

和工厂模式类似,就像是多个工厂模式合并到一起，中间多了一层抽象类，将多个工厂抽象出来，然后创建超级工厂，根据不同的信息生成不同的对象

#### 作用

- 主要解决接口选择问题，不同条件下创建不同实例
- 子类实现工厂接口，返回的也是一个抽象的产品
- 创建过程在其子类执行

### 单例模式

#### 作用

- 保证一个类仅有一个实例，提供一个访问它的全局访问点
- 解决全局使用的类频繁地创建与销毁
- 当想要控制实例数目，节省系统资源的时候使用

#### 实现

#### 使用场景

- 生成唯一序列号
- 创建一个对象需要消耗的资源更多时，I/O 与数据库连接等

##### 懒汉式，线程不安全

是否 Lazy 初始化：是（使用的时候才初始化）
是否多线程安全：否
实现难度：易
描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。
这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

```java
public class Singleton {
    private static Singleton instance;
    private Singleton (){}

    public static Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
    }
}
```

##### 懒汉式，线程安全

是否 Lazy 初始化：是（使用的时候才初始化）
是否多线程安全：是
实现难度：易

描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
优点：第一次调用才初始化，避免内存浪费。
缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）

```java
public class Singleton {
    private static Singleton instance;
    private Singleton (){}
    public static synchronized Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
    }
}
```

##### 饿汉式

是否 Lazy 初始化：否(加载的时候就初始化了)
是否多线程安全：是
实现难度：易
描述：这种方式比较常用，但容易产生垃圾对象。
优点：没有加锁，执行效率会提高。
缺点：类加载时就初始化，浪费内存。
它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton (){}
    public static Singleton getInstance() {
    return instance;
    }
}
```

##### 双检锁/双重校验锁

JDK 版本：JDK1.5 起
是否 Lazy 初始化：是
是否多线程安全：是
实现难度：较复杂
描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
getInstance() 的性能对应用程序很关键。

```java
public class SingletonDCL {


    /**
     * 使用volatile 关键字是为了避免某些编译器为了性能，对代码进行编译重排，使用改关键字之后重排会被禁止
     * 正常流程是：
     * 1.分配内存空间
     * 2.初始化对象
     * 3.将对象指向刚分配的内存空间
     * 有些编译器可能是将2，3顺序颠倒了
     */
    private volatile static SingletonDCL singletonDCL;

    private SingletonDCL() {
    }

    // 先判断对象是否已经被初始化，再决定要不要加锁
    public static SingletonDCL getSingletonDCL() {
        if (singletonDCL == null) {
            synchronized (SingletonDCL.class) {
                if (singletonDCL == null) {
                    singletonDCL = new SingletonDCL();
                }
            }
        }
        return singletonDCL;
    }
}
```

##### 静态内部类

是否 Lazy 初始化：是
是否多线程安全：是
实现难度：一般
描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。
这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。

```java
public class SingletonRegistration {
    // 能达到和双检锁方式也一样的功效，但实现更简单，对静态域使用延迟初始化，应使用这种方式
    // 这种方式只适用静态域的情况，双检锁方式可在实例域需要延迟初始化时使用
    private static class SingletonHolder{
        private static final SingletonRegistration INSTANCE = new SingletonRegistration();
    }
    private SingletonRegistration(){}
    public static final SingletonRegistration getInstance(){
        return SingletonHolder.INSTANCE;
    }
}
```

##### 枚举

JDK 版本：JDK1.5 起

是否 Lazy 初始化：否

是否多线程安全：是

实现难度：易

描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。
这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
不能通过 reflection attack 来调用私有构造方法。

```java
public enum Singleton {
    INSTANCE;
    public void whateverMethod() {
    }
}
```

### 建造者模式

### 原型模式

## 结构型模式

### 适配器模式

### 桥接模式

#### 作用

- 当系统有多个维度，每个维度都是单独变化的，这个时候可以使用桥接模式

#### 实现

- 创建抽象类 A

### 过滤器模式

### 组合模式

### 装饰器模式

#### 作用

- 本质上是使用继承的方式新增功能，动态地给一个对象添加一些额外的职责

#### 使用

- 创建接口 A
- B 实现接口 A
- C 扩展接口 B，新增功能

### 外观模式

### 享元模式

### 代理模式

#### 作用

- 一个类代表另外一个类的功能
- 为其他对象提供一种代理以控制对这个对象的访问

#### 使用

- 创建接口
- 对象 A 对接口实现
- 对象 B 对接口实现，创建对象 A 的私有属性

#### 使用场景

- 当直接访问对象会存在一些问题（比如参数校验之类的），我们可以通过代理类，并在里面实现参数校验

## 行为模式

### 责任链模式

### 命令模式

### 解释器模式

### 迭代器模式

### 中介者模式

### 备忘录模式

### 观察者模式

#### 作用

- 当一个对象的状态发生改变的时候，所有依赖于它的对象都得到通知并被自动更新

#### 使用

- 创建主类 A，需要记录观察者列表，有新增观察者和通知观察者功能
- 创建观察者 B 抽象类，更新操作，抽象方法 update
- 观察者 C 继承观察者 B，实现更新操作，构造器内部，新增观察者，初始化 A
- 观察者 D 同上

### 状态模式

### 空对象模式

### 策略模式

> 策略模式通俗来说就是定义一个统一的接口，然后对这个接口有不同的实现，然后通过定义一个 Context 来选择执行那个实现。

> 在策略模式中，一个类的行为或者其算法可以在运行时更改，这种类型的设计模式属于行为模式
> 在策略模式中，创建各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法

### 模板模式

#### 作用

- 抽象类公开定义执行它的方法的方式/模板，子类按需重写方法实现，但是调用将以抽象类中定义的方式进行。

* 解决一些方法是通用的，却在每一个子类中都要重写这些方法
* 将通用的方法都抽象出来，封装不变部分，扩展可变部分，提取公共代码便于维护
* 模板方法设为 final，这样就不会被重写了

#### 使用

- 定义抽象类 A，抽象一系列接口，并定义模板方法
- B 继承 A，实现抽象方法
- C 继承 A，实现抽象方法

### 访问者模式

## J2EE 模式

### MVC 模式

### 业务代表模式

### 组合实体模式

#### 作用

- 将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
- 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

#### 使用

- 定义对象 A，对象中包含当前员工，和他所以后的下属属性

### 数据访问对象模式

### 前端控制器模式

### 拦截过滤器模式

### 服务定位器模式

### 传输对象模式

## spring 中用到的设计模式

- 简单工厂模式
- 工厂方法模式
- 单例模式
- 适配器模式
- 装饰器模式
- 代理模式
- 观察者模式
- 策略模式
- 模板方法模式
