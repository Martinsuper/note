# 最优线程数问题

对于包含了 I/O 和其他阻塞操作的任务，不是所有的线程都会在所有的时间被调度，因此你需要一个更大的池。为了正确地设置线程池的长度，你必须估算出任务花在等待的时间与用来计算的时间的比率；这个估算值不必十分精确，而且可以通过一些监控工具获得。你还可以选择另一种方法来调节线程池的大小，在一个基准负载下，使用 几种不同大小的线程池运行你的应用程序，并观察 CPU 利用率的水平。

```
Ncpu = CPU的数量
Ucpu = 目标CPU的使用率， 0 <= Ucpu <= 1
W/C = 等待时间与计算时间的比率
为保持处理器达到期望的使用率，最优的池的大小等于：
Nthreads = Ncpu x Ucpu x (1 + W/C)
```

> 获取 cpu 数量 java 可以使用 `Runtime.getRuntime().availableProcessors()`

当任务需要使用池化的资源时，比如数据库连接，那么线程池的长度和资源池的长度会相互影响。如果每一个任务都需要一个数据库连接，那么连接池的大小就限制了线程池的有效大小；类似地，当线程池中的任务是连接池的唯一消费者时，那么线程池的大小反而又会限制了连接池的有效大小。

```
Nthreads = Ncpu x Ucpu x (1 + W/C)，其中
Ncpu = CPU核心数
Ucpu = CPU使用率，0~1
W/C = 等待时间与计算时间的比率
```

> 为使用尽可能多的处理器核心数，可以设置应用程序的最小线程数等于可用的处理器核心数。

> 对于所有任务都是计算密集型的，创建处理器可用核心数那么多的线程就够了

对于 io 密集型任务，需要开更多的线程来提高性能，因为对于 IO 密集型而言，io 操作远慢于 cpu 处理速度。当一个任务执行 IO 操作时，其线程将被阻塞，处理器可以立即进行上线文切换以便处理其他就绪线程。这个可以根据任务阻塞时间来设置线程数，如果任务有 50%的时间处于阻塞状态，则程序所需线程数为核心数的 2 倍。如果线程阻塞时间少于 50%，说明是计算密集型的，程序所需线程数随之减少，但是最少不应该低于处理器的核心数。

- 线程数 = CPU 可用核心数/(1-阻塞系数)

* 计算密集型阻塞系数为 0，而 IO 密集型任务的阻塞系数接近 1。完全阻塞的任务注定要挂掉
* 现在假设将方法二的公式等于方法一公式，即 Ncpu /（1 - 阻塞系数）= Ncpu x (1 + W/C)，推导出：阻塞系数 = W / (W + C)，即阻塞系数 = 阻塞时间 /（阻塞时间 + 计算时间）

> 由于对 Web 服务的请求大部分时间都花在等待服务器响应上了，所以阻塞系数会相当高，因此程序需要开的线程数可能是处理器核心数的若干倍。假设阻塞系数是 0.9，即每个任务 90%的时间处于阻塞状态而只有 10%的时间在干活，则在双核处理器上我们就需要开 20 个线程（使用第 2.1 节的公式计算）。如果有很多只股票要处理的话，我们可以在 8 核处理器上开到 80 个线程来处理该任务。

## 总结

- 对于计算密集型，线程数=CPU 核心数
- 对于 IO 密集型，线程数=2 倍 CPU 核心数

[参考](https://juejin.im/post/5ec62f26e51d4578853d1918)
