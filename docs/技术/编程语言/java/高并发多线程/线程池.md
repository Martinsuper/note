# 线程池

## java 线程池创建

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```

- corePoolSize：核心线程数，线程池中存活的线程数
- maximumPoolSize：线程池中最大线程数量
- keepAliveTime：当线程池中空闲线程超过核心线程数时，多余的线程会在多久被销毁
- unit：keepAliveTime 的单位
- workQueue：任务队列，被添加到线程池中，但是尚未被执行的任务，它一般分为直接提交队列、有界任务队列、无界任务队列、优化任务队列几种。
- threadFactory：线程工厂，用于创建线程
- handler：拒绝策略；当任务太多来不及处理时，如何拒绝

### 阻塞队列

阻塞队列主要分为：

- 直接提交队列
  - 功能由 `SynchronousQueue` 对象提供，是一个特殊的队列，它没有容量，每插入一个操作都要等待一个相应的删除操作，每个删除操作也都要等待对应的插入操作。提交的任务不会被真是的保存，而是将新的任务提交给线程执行，如果没有空余的线程，则尝试创建新的线程，如果线程数达到最大值，则执行拒绝策略。
- 有界队列
  - `AarrayBlockingQueue` 实现，构造函数必须带一个容量参数，表示队列的最大容量。当使用有界队列时，若有新的任务需要执行，如果线程池的实际线程数小于核心线程数，则会优先创建新的线程，如果大于核心线程数，则会将新任务加入到等待队列中。若等待队列已经满了，无法加入，则在总线程数不超过最大线程数的前提下创建新线程。如果线程数已经达到最大值，则执行拒绝策略。除非系统非常繁忙，否则确保核心线程数维持在指定的核心线程数。
- 无界队列
  - 无界队列通过 `LinkedBlockingDeque` 类实现。与有界队列相比，除非系统资源耗尽，否则无界队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于核心线程数，线程池会生成新的线程执行任务，但当系统的线程数达到核心线程数后就不会增加。若后续仍有新的任务加入，而又没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。
- 优先队列
  - 优先任务队列是通过 `PriorityBlockingQueue`实现，可以控制任务的执行先后顺序。它是一个特殊的无界队列。无论是有界队列 `AarrayBlockingQueue`，还是未指定大小的无界队列 `LinkedBlockingDeque`，都是按照先进先出处理任务的，而 `PriorityBlockingQueue` 则可以根据任务自身的优先顺序先后执行，在确保系统性能的同时，也能有很好的质量保证。

## 线程池分类

- newFixedThreadPool
  - 固定数目线程的线程池

## newFixedThreadPool guding

> 创建一个可重用不受限制的队列操作线程的固定数目的线程池。 在任何时候，顶多 nThreads 线程将被激活的处理任务。 如果当所有线程是活动的其他任务提交，他们将在队列中等待，直到一个线程可用。 如果任何线程关闭前的执行过程中，由于终止与失败，如果需要执行后续任务的新一个将取而代之。 在池中的线程将一直存在，直到它明确地 shutdown
> 线程池特点：

- 阻塞队列为无界队列 LinkedBlockingQueue
- 没有所谓的非空闲时间，即 keepAliveTime 为 0
- 核心线程数和最大线程数大小一样

```java
public void testFixedThreadPool(){
    ExecutorService executor = Executors.newFixedThreadPool(3);
    for (int i = 0; i < 5; i++) {
        executor.execute(() -> {
            System.out.println(Thread.currentThread().getName() + "正在执行");
        });
    }
}

```

![固定线程数线程池](https://gitee.com/martind/image/raw/master/younote/thread/%E5%9B%BA%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8.png)

## newScheduledThreadPool

```java
    public static void main(String[] args) {
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
        scheduledExecutorService.scheduleWithFixedDelay(() -> {
            System.out.println("current Time" + System.currentTimeMillis());
            System.out.println(Thread.currentThread().getName() + "正在执行");
        }, 1, 30, TimeUnit.SECONDS);
    }

```
