# 多线程相关概念

> 多线程编程的核心是分工、同步、互斥，即高效的拆解任务并分配给线程，同步指的是线程之间如何协作，其核心是管程；互斥则是保证同一时刻只允许一个线程访问共享资源（线程安全）。

> 线程

线程是独立调度和分派的基本单位。

> 进程

进程是资源分配的基本单位。所有与该进程有关的资源，都会被记录在进程控制块 PCB（一种数据结构，表示进程状态）中。

> 并发编程是解决什么问题的？

我们大多数的任务都需要 CPU、内存、IO 设备之间协调工作才能完成，但是 CPU、内存、IO 设备之间有一个核心矛盾，那就是他们之间的速度差距很大，很大；cpu 的速度大概是内存的几百倍，内存速度又是 IO 设备速度的上千倍。而程序速度却又是取决于最慢的操作，所以 cpu 速度这么快也就没有用了。这个时候这个矛盾我们很难从硬件层次解决，我们可以从程序的角度来解决这个问题，cpu 速度快，那你不能干等着，可以在别人忙的时候做剩下的事情，这样不就提高效率了嘛。

> 为什么会出现缓存的可见性

为了解决 cpu 和内存之间的差距，还从硬件层次引入了缓存，但是引入缓存又会出现其他的问题，那就是 cpu 缓存和内存的数据不一致问题。对于多核 cpu，每个 cpu 都有自己的缓存，这个时候就出问题了；如下线程 A 在 cpu1 上运行，线程 B 在 cpu2 上运行，两个线程都是基于 cpu 缓存里面的 count 值来计算的，这个时候就出现问题了，如下无论如何运算的结果都不是 20000

```java
public class ThreadLearn {
    private static long count = 0;
    @Test
    public void test() throws InterruptedException {
        System.out.println(calc());
    }

    private void add10K() {
        int idx = 0;
        while(idx++ < 10000) {
            count += 1;
        }
    }
    public static long calc() throws InterruptedException {
        final ThreadLearn test = new ThreadLearn();
        // 创建两个线程，执行 add() 操作
        Thread th1 = new Thread(()->{
            test.add10K();
        });
        Thread th2 = new Thread(()->{
            test.add10K();
        });
        // 启动两个线程
        th1.start();
        th2.start();
        // 等待两个线程执行结束
        th1.join();
        th2.join();
        return count;
    }
}
```

> 线程切换带来的原子性问题

为什么要用线程切换呢？由于 IO 太慢，早期操作系统就发明了多进程，操作系统通过时间片轮转的方式重新选择一个进程执行任务。
比如执行 count+=1,这条指令至少需要三条 cpu 指令

- 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；
- 指令 2：之后，在寄存器中执行 +1 操作；
- 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。
  操作系统做任务切换，可以发生在任何一条 CPU 指令执行完，因为这个操作过程不是原子性的，这个时候就容易出现问题了。线程 A 把 count=0 从内存加载到寄存器，这个时候切换到线程 B，线程 B 也把 count=0 加载到寄存器，线程 B 执行 count+1=1，然后把 count=1 写入内存，然后切换到线程 B，count+1=1，然后把 count=1 写入内存，最后 count=1，其实应该 count=2 的。

> 编译优化带来的有序性问题

在学习单例模式的时候我们知道单例模式有懒汉模式、饿汉模式、双重校验锁等方式，双重校验锁中就针对编译器优化做了处理，具体解释看这里[双重校验锁](../../../基础/设计模式/设计模式概述.md#单例模式)

## java 内存模型

> java 内存模型的主要目标是定义程序中变量的访问规则，即虚拟机中将变量存储到主内存或者将变量从主内存取出这样的底层细节
> java 虚拟机中主内存和工作内存交互，就是一个变量如何从主内存传输到工作内存中，如何把修改后的变量从工作内存同步回主内存。

- lock(锁定):作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量
- unlock(解锁):作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定
- read(读取):作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的 load 操作使用
- load(载入):作用于线程的工作内存的变量，表示把 read 操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)
- use(使用):作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作
- assign(赋值):作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作
- store(存储):作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的 write 操作使用
- write(写入):作用于主内存的变量，把 store 操作从工作内存中得到的变量的值放入主内存的变量中

java 虚拟机执行规则如下：

- 不允许 read 和 load、store 和 write 操作之一单独出现
- 不允许一个线程丢弃最近的 assign 操作
- 不允许一个线程回写没有修改的变量到主内存
- 变量只能在主内存中产生
- 一个变量在同一时刻只能被一个线程对其进行 lock 操作
- 对变量执行 lock 操作，就会清空工作空间该变量的值
- 不允许对没有 lock 的变量执行 unlock 操作
- 对一个变量执行 unlock 之前，必须先把变量同步回主内存中

允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，也就是允许虚拟机不保证对 64 位数据的 read、load、store 和 write 这 4 个动作的操作是原子的。这也就是我们常说的 long 和 double 的非原子性协定

### java 内存模型的实质

[参考](https://www.jianshu.com/p/15106e9c4bf3)

#### 原子性(Automicity)

由 Java 内存模型来直接保证原子性的变量操作包括 read、load、use、assign、store、write 这 6 个动作，虽然存在 long 和 double 的特例，但基本可以忽律不计，目前虚拟机基本都对其实现了原子性。如果需要更大范围的控制，lock 和 unlock 也可以满足需求。lock 和 unlock 虽然没有被虚拟机直接开给用户使用，但是提供了字节码层次的指令 monitorenter 和 monitorexit 对应这两个操作，对应到 java 代码就是 synchronized 关键字，因此在 synchronized 块之间的代码都具有原子性。

#### 可见性

可见性是指一个线程修改了一个变量的值后，其他线程立即可以感知到这个值的修改。正如前面所说，volatile 类型的变量在修改后会立即同步给主内存，在使用的时候会从主内存重新读取，是依赖主内存为中介来保证多线程下变量对其他线程的可见性的。
除了 volatile，synchronized 和 final 也可以实现可见性。synchronized 关键字是通过 unlock 之前必须把变量同步回主内存来实现的，final 则是在初始化后就不会更改，所以只要在初始化过程中没有把 this 指针传递出去也能保证对其他线程的可见性。

#### 有序性

有序性从不同的角度来看是不同的。单纯单线程来看都是有序的，但到了多线程就会跟我们预想的不一样。可以这么说：如果在本线程内部观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句说的就是“线程内表现为串行的语义”，后半句值得是“指令重排序”现象和主内存与工作内存之间同步存在延迟的现象。
保证有序性的关键字有 volatile 和 synchronized，volatile 禁止了指令重排序，而 synchronized 则由“一个变量在同一时刻只能被一个线程对其进行 lock 操作”来保证。

总体来看，synchronized 对三种特性都有支持，虽然简单，但是如果无控制的滥用对性能就会产生较大影响。

### volatile

:::tip
`volatile` 关键字就是告诉编译器禁止使用 cpu 缓存，直接从内存里面读取，防止出现缓存可见性问题， `volatile` 类型的变量保证对所有线程的可见性，volatile 类型的变量禁止指令重排序优化
:::

### java解决可见性和有序性问题

#### Happerns-Before 规则
> 前一个操作的结果对后续操作是可见的
主要包括如下几项规则：
* 程序的顺序性规则
* `volatile` 变量规则
* 传递性
* 管程中锁的规则（管程是一种通用的同步原语，java中指的是`synchronized`）
* 线程 `start()` 规则
* 线程 `join()` 规则
  * 主线程 A 等待 子线程B完成
* `final` 关键字修饰的的变量生而不变

思考：
有一个共享变量 abc，在一个线程里设置了 abc 的值 abc=3，你思考一下，有哪些办法可以让其他线程能够看到abc==3？